---
layout: post
title: "享元模式"
categories: 设计模式
tags: 设计模式
author: August
typora-root-url: ..
---

* content
{:toc}


本文介绍享元模式定义、结构、特点、适用场景、代码实现。



# 享元模式



## 1 模式的定义

享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。



## 2 模式的结构

### 2.1 结构图

![享元设计模式的结构](/media/image/2022-10-05-享元模式/Flyweight.png)

### 2.2 参与者

1. 享元（Flyweight）类包含原始对象中部分能在多个对象中共享的状态。同一享元对象可在许多不同情景中使用。享元中存储的状态被称为“内在状态”。传递给享元方法的状态被称为“外在状态”。
2. 情景（Context）类包含原始对象中各不相同的外在状态。情景与享元对象组合在一起就能表示原始对象的全部状态。
3. 享元工厂（Flyweight Factory）会对已有享元的缓存池进行管理。有了工厂后，客户端就无需直接创建享元，它们只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回；如果没有找到就根据参数新建享元。



## 3 模式分析

### 3.1 优点

- 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

### 3.2 缺点

- 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。



## 4 适用环境

- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。

- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。



## 5 实现方式

- 将需要改写为享元的类成员变量拆分为两个部分：
  - 内在状态：包含不变的、可在许多对象中重复使用的数据的成员变量。
  - 外在状态：包含每个对象各自不同的情景数据的成员变量。
- 保留类中表示内在状态的成员变量，并将其属性设置为不可修改。这些变量仅可在构造函数中获得初始数值。
- 找到所有使用外在状态成员变量的方法，为在方法中所用的每个成员变量新建一个参数，并使用该参数代替成员变量。
- 你可以有选择地创建工厂类来管理享元缓存池，它负责在新建享元时检查已有的享元。如果选择使用工厂，客户端就只能通过工厂来请求享元，它们需要将享元的内在状态作为参数传递给工厂。
- 客户端必须存储和计算外在状态（情景）的数值，因为只有这样才能调用享元对象的方法。为了使用方便，外在状态和引用享元的成员变量可以移动到单独的情景类中。



## 6 代码实现

[https://github.com/august295/DesignPatternCode](https://github.com/august295/DesignPatternCode)



## 参考

[1] [https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html)

[2] [https://refactoringguru.cn/design-patterns/flyweight](https://refactoringguru.cn/design-patterns/flyweight)
