---
layout: post
title: "TCP图解"
categories: Network
tags: Network
author: August
typora-root-url: ..
---

* content
{:toc}

该文记录 `TCP` 简介和通信流程。



# TCP图解



## 1. 定义[^1]

TCP是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议。TCP属于传输层协议，传输层协议与网络层协议之间的主要区别是，网络层协议是为主机之间提供逻辑通信的，而传输层协议是为应用**进程**之间提供**端到端**的逻辑通信的。这里的端到端指的就是套接字(Socket)。

TCP的全部功能都体现在它首部中各字段的作用。

![](/media/image/2024-02-19-TCP图解/tcp_header.png)



## 2. 通信过程[^2]

TCP通信过程包括三个步骤：建立TCP连接通道，传输数据，断开TCP连接通道。

![](/media/image/2024-02-19-TCP图解/tcp-ip-handshark.png)

1. 建立TCP连接很简单，通过三次握手便可建立连接。
2. 建立好连接后，开始传输数据。TCP数据传输牵涉到的概念很多：超时重传、快速重传、流量控制、拥塞控制等等。
3. 断开连接的过程也很简单，通过四次握手完成断开连接的过程。

### 2.1. 三次握手

1. 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

### 2.2. 数据传输

1. 超时重传：
2. 快速重传：
3. 流量控制：
4. 拥塞控制：拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。

### 2.3. 四次挥手

1. 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据。
2. 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
3. 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
4. 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。



## 3. 编码流程[^3]

![](/media/image/2024-02-19-TCP图解/tcp_code.svg)

服务端：

1. 调用 `socket` 函数创建 `socket`
2. 调用 `bind` 函数将 `socket` 绑定到某个IP和端口
3. 调用 `listen` 函数开启监听
4. 当有客户端请求连接上来时，调用 `accept` 函数接收连接，产生一个新的 `socket`
5. 基于新的 `socket` 调用 `recve` 或者 `send` 函数，开始与客户端进行数据交互
6. 通信结束后，调用 `close` 函数关闭监听 `socket`

客户端：

1. 调用 `socket` 函数创建客户端 `socket`
2. 调用 `connect` 函数尝试连接服务器
3. 连接成功后调用 `send` 或 `recv` 函数，开始与服务器进行数据交互
4. 通信结束后，调用 `close` 函数关闭监听 `socket`





# 参考

[^1]: [TCP协议](https://evanpro.github.io/2021/01/31/network/tcp/)

[^2]: [图解TCP/IP协议](https://liubigbin.github.io/2016/02/26/%E5%9B%BE%E8%A7%A3TCP-IP%E5%8D%8F%E8%AE%AE/)

[^3]: [socket编程实现tcp服务器_C/C++](https://www.cnblogs.com/yunmeng-shi/p/16219550.html)

